# eventcount

Returns the number of events in specified indexes.

## Examples:

### | eventcount summarize=false index=_audit index=main

This SPL line | eventcount summarize=false index=_audit index=main tells Splunk to generate an exact, raw-level count of how many events exist in the _audit and main indexes by bypassing the fast TSIDX summaries and scanning the underlying event data directly. Because eventcount is a generating command, the pipe at the beginning simply starts the search with it, without needing a prior term. The summarize=false flag is the crucial part: instead of returning approximate or metadata-based counts from the index summaries (which is usually fast but can be slightly off if TSIDX files are stale, corrupt, or rebuilding), Splunk is instructed to walk through the actual rawdata files inside each bucket and count events one by one. This produces an exact, authoritative event count at the cost of greater time and resource usage. The result is a precise per-index total for _audit and main, typically used for troubleshooting indexing issues, validating ingestion, or verifying bucket consistency.

### | eventcount summarize=false index=_* report_size=true

This SPL line | eventcount summarize=false index=_* report_size=true tells Splunk to generate a raw, highly detailed count of all events across every internal index (because index=_* matches _internal, _audit, _introspection, etc.) while also forcing Splunk to read the underlying raw event files rather than relying on fast TSIDX metadata. The summarize=false flag makes Splunk scan the real event data inside each bucket—much slower but fully accurate—so you get a precise event count even if index summaries are outdated or buckets are partially corrupted. The additional argument report_size=true instructs Splunk to include extra fields describing the storage footprint of each index (such as the combined size of its buckets), giving you not just how many events each internal index contains but also how much disk space those events consume. In a single command, you’re essentially asking Splunk to: (1) enumerate all internal indexes, (2) deeply inspect each one’s rawdata buckets, (3) count events with full accuracy, and (4) report size information for storage-level visibility—making this a powerful diagnostic tool for understanding ingestion volume and storage health inside the Splunk platform.

### | eventcount summarize=false index=*

This SPL line | eventcount summarize=false index=* tells Splunk to generate an exact, bucket-level count of all events across every index in the system, but to do it in the slowest and most accurate way possible by scanning the raw event data instead of using TSIDX summaries. Because eventcount is a generating command, the pipe at the beginning simply starts the search with it, and the index=* argument instructs Splunk to include all available indexes—internal, external, custom, everything the user has permission to see. The key parameter is summarize=false, which forces Splunk to bypass its fast metadata-based method of counting and instead iterate through each bucket’s rawdata files, reading events directly and counting them one by one. This produces perfectly accurate event totals across all indexes, even if summary files are damaged or inconsistent, but it also consumes more CPU and takes significantly longer on large systems. The result is a table showing every index alongside the exact number of events it currently holds, making this command useful for deep diagnostics, validation of ingestion, and verifying index health at the raw storage level.

### | eventcount summarize=f list_federated_remote=t index=access_* index=federated:access_*

The command starts with eventcount, a generating command that produces counts without needing a prior search, and the flag summarize=f (equivalent to summarize=false) instructs Splunk to avoid using TSIDX summaries and instead perform a deeper, more literal scan of the underlying events for local indexes. The argument list_federated_remote=t (true) is what makes this special: it tells Splunk to include remote federated indexes in the event count, not just their local metadata stubs. The two index patterns—index=access_* and index=federated:access_*—tell Splunk to count events in all locally stored indexes whose names start with access_, and simultaneously count events in all federated indexes with the same naming pattern, pulling counts directly from the remote Splunk or S3-based federated provider. The final result is a unified table where Splunk displays accurate per-index event counts for both your local access logs and your remote federated access logs, treating them as a single logical data layer while still distinguishing their locations.
